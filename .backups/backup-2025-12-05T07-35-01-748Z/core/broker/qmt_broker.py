# -*- coding: utf-8 -*-
"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")






"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")






"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")






"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")






"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")






"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")






"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")






"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")






"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")






"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")




"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")

"""
QMT券商接口实现
基于xtquant库（miniQMT专用Python量化库）

SDK获取：https://dict.thinktrader.net/nativeApi/download_xtquant.html?id=NF25nX
注意：券商版QMT支持的最高版本为xtquant_241014
"""
from typing import List, Dict, Optional, Callable
from datetime import datetime
import logging
import time

from .base import (
    IBroker, BrokerStatus, OrderStatus, OrderSide, OrderType,
    Order, Position, Account
)

logger = logging.getLogger(__name__)


class QMTBroker(IBroker):
    """
    QMT券商接口
    
    使用xtquant库连接miniQMT进行交易
    支持股票、ETF等A股交易品种
    """
    
    # QMT订单状态映射
    QMT_ORDER_STATUS_MAP = {
        48: OrderStatus.PENDING,       # 未报
        49: OrderStatus.SUBMITTED,     # 待报
        50: OrderStatus.SUBMITTED,     # 已报
        51: OrderStatus.SUBMITTED,     # 已报待撤
        52: OrderStatus.PARTIAL_FILLED,# 部成待撤
        53: OrderStatus.PARTIAL_FILLED,# 部撤
        54: OrderStatus.CANCELLED,     # 已撤
        55: OrderStatus.PARTIAL_FILLED,# 部成
        56: OrderStatus.FILLED,        # 已成
        57: OrderStatus.REJECTED,      # 废单
    }
    
    def __init__(self, name: str = "QMT"):
        super().__init__(name)
        self._xt_trader = None
        self._xt_data = None
        self._account_id = ""
        self._session_id = 0
        self._quote_callback = None
        self._subscribed_stocks = set()
        
    def connect(
        self,
        path: str = "",
        account_id: str = "",
        session_id: int = 0,
        **kwargs
    ) -> bool:
        """
        连接QMT
        
        Args:
            path: miniQMT安装路径（如 C:/国金证券QMT/userdata_mini）
            account_id: 资金账号
            session_id: 会话ID（默认0）
        
        Returns:
            bool: 是否连接成功
        """
        try:
            self._status = BrokerStatus.CONNECTING
            logger.info(f"正在连接QMT: path={path}, account={account_id}")
            
            # 尝试导入xtquant
            try:
                from xtquant import xttrader
                from xtquant import xtdata
                from xtquant.xttrader import XtQuantTrader, XtQuantTraderCallback
                from xtquant.xttype import StockAccount
            except ImportError as e:
                logger.error(f"无法导入xtquant库: {e}")
                logger.info("请从迅投官网下载xtquant: https://dict.thinktrader.net/nativeApi/download_xtquant.html")
                self._status = BrokerStatus.ERROR
                self._emit('on_error', "xtquant库未安装")
                return False
            
            # 创建回调类
            class TraderCallback(XtQuantTraderCallback):
                def __init__(self, broker):
                    super().__init__()
                    self.broker = broker
                
                def on_disconnected(self):
                    logger.warning("QMT连接断开")
                    self.broker._status = BrokerStatus.DISCONNECTED
                    self.broker._emit('on_disconnected')
                
                def on_stock_order(self, order):
                    logger.debug(f"订单回报: {order.order_id}")
                    self.broker._handle_order_update(order)
                
                def on_stock_trade(self, trade):
                    logger.debug(f"成交回报: {trade.order_id}")
                    self.broker._handle_trade(trade)
                
                def on_order_error(self, order_error):
                    logger.error(f"订单错误: {order_error.error_msg}")
                    self.broker._emit('on_error', order_error.error_msg)
                
                def on_cancel_error(self, cancel_error):
                    logger.error(f"撤单错误: {cancel_error.error_msg}")
                    self.broker._emit('on_error', cancel_error.error_msg)
                
                def on_order_stock_async_response(self, response):
                    logger.debug(f"异步下单响应: {response.order_id}")
                
                def on_account_status(self, status):
                    logger.debug(f"账户状态: {status.status}")
            
            # 创建交易对象
            self._xt_trader = XtQuantTrader(path, session_id)
            
            # 注册回调
            callback = TraderCallback(self)
            self._xt_trader.register_callback(callback)
            
            # 启动交易线程
            self._xt_trader.start()
            
            # 连接服务器
            connect_result = self._xt_trader.connect()
            if connect_result != 0:
                logger.error(f"QMT连接失败: {connect_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 订阅账户
            self._account_id = account_id
            account = StockAccount(account_id)
            subscribe_result = self._xt_trader.subscribe(account)
            if subscribe_result != 0:
                logger.error(f"订阅账户失败: {subscribe_result}")
                self._status = BrokerStatus.ERROR
                return False
            
            # 初始化行情接口
            self._xt_data = xtdata
            
            self._status = BrokerStatus.CONNECTED
            logger.info("QMT连接成功")
            self._emit('on_connected')
            return True
            
        except Exception as e:
            logger.error(f"QMT连接异常: {e}")
            self._status = BrokerStatus.ERROR
            self._emit('on_error', str(e))
            return False
    
    def disconnect(self) -> bool:
        """断开QMT连接"""
        try:
            if self._xt_trader:
                self._xt_trader.stop()
                self._xt_trader = None
            
            self._status = BrokerStatus.DISCONNECTED
            logger.info("QMT已断开连接")
            self._emit('on_disconnected')
            return True
            
        except Exception as e:
            logger.error(f"断开QMT连接异常: {e}")
            return False
    
    def check_connection(self) -> bool:
        """检查连接状态"""
        return self._status == BrokerStatus.CONNECTED and self._xt_trader is not None
    
    def get_account(self) -> Optional[Account]:
        """获取账户信息"""
        if not self.check_connection():
            return None
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            asset = self._xt_trader.query_stock_asset(account)
            
            if asset:
                self._account = Account(
                    account_id=self._account_id,
                    account_type="stock",
                    total_asset=asset.total_asset,
                    cash=asset.cash,
                    frozen=asset.frozen_cash,
                    market_value=asset.market_value,
                )
                return self._account
            return None
            
        except Exception as e:
            logger.error(f"获取账户信息失败: {e}")
            return None
    
    def get_positions(self) -> List[Position]:
        """获取持仓列表"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            positions = self._xt_trader.query_stock_positions(account)
            
            result = []
            for pos in positions:
                position = Position(
                    stock_code=pos.stock_code,
                    stock_name=pos.stock_name if hasattr(pos, 'stock_name') else "",
                    quantity=pos.volume,
                    available=pos.can_use_volume,
                    cost_price=pos.open_price,
                    current_price=pos.market_value / pos.volume if pos.volume > 0 else 0,
                    market_value=pos.market_value,
                )
                self._positions[pos.stock_code] = position
                result.append(position)
            
            return result
            
        except Exception as e:
            logger.error(f"获取持仓失败: {e}")
            return []
    
    def get_position(self, stock_code: str) -> Optional[Position]:
        """获取单个股票持仓"""
        positions = self.get_positions()
        for pos in positions:
            if pos.stock_code == stock_code:
                return pos
        return None
    
    def place_order(
        self,
        stock_code: str,
        side: OrderSide,
        quantity: int,
        price: float = 0.0,
        order_type: OrderType = OrderType.LIMIT
    ) -> Optional[str]:
        """下单"""
        if not self.check_connection():
            logger.error("未连接QMT，无法下单")
            return None
        
        try:
            from xtquant.xttype import StockAccount
            from xtquant import xtconstant
            
            account = StockAccount(self._account_id)
            
            # 转换订单类型
            if order_type == OrderType.MARKET:
                price_type = xtconstant.LATEST_PRICE  # 最新价
            elif order_type == OrderType.BEST:
                price_type = xtconstant.FIVE_LEVEL_PRICE  # 最优五档
            else:
                price_type = xtconstant.FIX_PRICE  # 限价
            
            # 转换买卖方向
            if side == OrderSide.BUY:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_BUY,
                    quantity, price_type, price
                )
            else:
                order_id = self._xt_trader.order_stock(
                    account, stock_code, xtconstant.STOCK_SELL,
                    quantity, price_type, price
                )
            
            if order_id > 0:
                # 创建订单对象
                order = Order(
                    order_id=str(order_id),
                    stock_code=stock_code,
                    side=side,
                    order_type=order_type,
                    price=price,
                    quantity=quantity,
                    status=OrderStatus.SUBMITTED
                )
                self._orders[str(order_id)] = order
                logger.info(f"下单成功: {order_id}, {stock_code}, {side.value}, {quantity}@{price}")
                return str(order_id)
            else:
                logger.error(f"下单失败: {order_id}")
                return None
                
        except Exception as e:
            logger.error(f"下单异常: {e}")
            return None
    
    def cancel_order(self, order_id: str) -> bool:
        """撤单"""
        if not self.check_connection():
            return False
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            result = self._xt_trader.cancel_order_stock(account, int(order_id))
            
            if result == 0:
                logger.info(f"撤单请求已发送: {order_id}")
                return True
            else:
                logger.error(f"撤单失败: {result}")
                return False
                
        except Exception as e:
            logger.error(f"撤单异常: {e}")
            return False
    
    def get_order(self, order_id: str) -> Optional[Order]:
        """获取订单信息"""
        if order_id in self._orders:
            return self._orders[order_id]
        return None
    
    def get_orders(self, status: Optional[OrderStatus] = None) -> List[Order]:
        """获取订单列表"""
        if not self.check_connection():
            return list(self._orders.values())
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            orders = self._xt_trader.query_stock_orders(account)
            
            result = []
            for o in orders:
                order_status = self.QMT_ORDER_STATUS_MAP.get(o.order_status, OrderStatus.UNKNOWN)
                
                order = Order(
                    order_id=str(o.order_id),
                    stock_code=o.stock_code,
                    side=OrderSide.BUY if o.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=o.price,
                    quantity=o.order_volume,
                    filled_quantity=o.traded_volume,
                    filled_price=o.traded_price,
                    status=order_status,
                    message=o.status_msg if hasattr(o, 'status_msg') else ""
                )
                self._orders[str(o.order_id)] = order
                
                if status is None or order.status == status:
                    result.append(order)
            
            return result
            
        except Exception as e:
            logger.error(f"获取订单列表失败: {e}")
            return list(self._orders.values())
    
    def get_trades(self) -> List[Dict]:
        """获取成交记录"""
        if not self.check_connection():
            return []
        
        try:
            from xtquant.xttype import StockAccount
            account = StockAccount(self._account_id)
            trades = self._xt_trader.query_stock_trades(account)
            
            result = []
            for t in trades:
                result.append({
                    'trade_id': str(t.traded_id),
                    'order_id': str(t.order_id),
                    'stock_code': t.stock_code,
                    'side': 'buy' if t.order_type in [23, 24] else 'sell',
                    'price': t.traded_price,
                    'quantity': t.traded_volume,
                    'amount': t.traded_amount,
                    'time': t.traded_time,
                })
            
            return result
            
        except Exception as e:
            logger.error(f"获取成交记录失败: {e}")
            return []
    
    def get_quote(self, stock_code: str) -> Optional[Dict]:
        """获取实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            # 获取最新行情
            data = self._xt_data.get_full_tick([stock_code])
            if stock_code in data:
                tick = data[stock_code]
                return {
                    'code': stock_code,
                    'price': tick['lastPrice'],
                    'open': tick['open'],
                    'high': tick['high'],
                    'low': tick['low'],
                    'volume': tick['volume'],
                    'amount': tick['amount'],
                    'bid_price': tick['bidPrice'],
                    'ask_price': tick['askPrice'],
                    'bid_volume': tick['bidVol'],
                    'ask_volume': tick['askVol'],
                    'time': tick['time'],
                }
            return None
            
        except Exception as e:
            logger.error(f"获取行情失败: {e}")
            return None
    
    def subscribe_quote(self, stock_codes: List[str], callback: Callable) -> bool:
        """订阅实时行情"""
        try:
            if self._xt_data is None:
                from xtquant import xtdata
                self._xt_data = xtdata
            
            self._quote_callback = callback
            
            def on_data(data):
                if self._quote_callback:
                    self._quote_callback(data)
            
            for code in stock_codes:
                self._xt_data.subscribe_quote(code, period='tick', callback=on_data)
                self._subscribed_stocks.add(code)
            
            logger.info(f"订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"订阅行情失败: {e}")
            return False
    
    def unsubscribe_quote(self, stock_codes: List[str]) -> bool:
        """取消订阅行情"""
        try:
            if self._xt_data is None:
                return True
            
            for code in stock_codes:
                self._xt_data.unsubscribe_quote(code)
                self._subscribed_stocks.discard(code)
            
            logger.info(f"取消订阅行情: {stock_codes}")
            return True
            
        except Exception as e:
            logger.error(f"取消订阅失败: {e}")
            return False
    
    def _handle_order_update(self, order_data):
        """处理订单更新"""
        try:
            order_id = str(order_data.order_id)
            status = self.QMT_ORDER_STATUS_MAP.get(order_data.order_status, OrderStatus.UNKNOWN)
            
            if order_id in self._orders:
                order = self._orders[order_id]
                order.status = status
                order.filled_quantity = order_data.traded_volume
                order.filled_price = order_data.traded_price
                order.update_time = datetime.now()
            else:
                order = Order(
                    order_id=order_id,
                    stock_code=order_data.stock_code,
                    side=OrderSide.BUY if order_data.order_type in [23, 24] else OrderSide.SELL,
                    order_type=OrderType.LIMIT,
                    price=order_data.price,
                    quantity=order_data.order_volume,
                    filled_quantity=order_data.traded_volume,
                    filled_price=order_data.traded_price,
                    status=status
                )
                self._orders[order_id] = order
            
            self._emit('on_order_update', order)
            
        except Exception as e:
            logger.error(f"处理订单更新异常: {e}")
    
    def _handle_trade(self, trade_data):
        """处理成交回报"""
        try:
            trade = {
                'trade_id': str(trade_data.traded_id),
                'order_id': str(trade_data.order_id),
                'stock_code': trade_data.stock_code,
                'price': trade_data.traded_price,
                'quantity': trade_data.traded_volume,
                'amount': trade_data.traded_amount,
                'time': datetime.now(),
            }
            self._emit('on_trade', trade)
            
        except Exception as e:
            logger.error(f"处理成交回报异常: {e}")














