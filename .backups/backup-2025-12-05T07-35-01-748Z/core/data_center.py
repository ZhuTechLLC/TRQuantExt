# -*- coding: utf-8 -*-
"""
数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
        logger.info(f"添加数据源: {name}")
    
    def remove_data_source(self, name: str):
        """移除数据源"""
        if name in self.data_sources:
            self.data_sources[name].disconnect()
            del self.data_sources[name]
            logger.info(f"移除数据源: {name}")
    
    def connect(self, source: str, **kwargs) -> bool:
        """连接数据源"""
        if source not in self.data_sources:
            logger.error(f"未知数据源: {source}")
            return False
        
        ds = self.data_sources[source]
        if ds.connect(**kwargs):
            if self.primary_source is None:
                self.primary_source = source
            logger.info(f"数据源 {source} 连接成功")
            return True
        
        return False
    
    def disconnect(self, source: str = None):
        """断开数据源"""
        if source:
            if source in self.data_sources:
                self.data_sources[source].disconnect()
        else:
            for ds in self.data_sources.values():
                ds.disconnect()
            self.primary_source = None
    
    def get_price(self, security: Union[str, List[str]], start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None,
                  source: str = None, use_cache: bool = True) -> pd.DataFrame:
        """
        获取价格数据
        
        Args:
            security: 股票代码或代码列表
            start_date: 开始日期
            end_date: 结束日期
            frequency: 频率 (daily, minute等)
            fields: 字段列表
            source: 指定数据源
            use_cache: 是否使用缓存
        
        Returns:
            价格数据DataFrame
        """
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        # 处理单个股票
        if isinstance(security, str):
            securities = [security]
        else:
            securities = security
        
        all_data = []
        
        for sec in securities:
            # 尝试从缓存获取
            if use_cache:
                cached = self.cache.get("price", sec, start_date, end_date, 
                                       frequency=frequency)
                if cached is not None:
                    all_data.append(cached)
                    continue
            
            # 从数据源获取
            try:
                df = ds.get_price(sec, start_date, end_date, frequency, fields)
                
                if df is not None and len(df) > 0:
                    df['security'] = sec
                    
                    # 缓存数据
                    if use_cache:
                        self.cache.set("price", sec, start_date, end_date, df)
                    
                    # 记录审计日志
                    self.audit.log(
                        action="get_price",
                        data_source=source,
                        security=sec,
                        start_date=start_date,
                        end_date=end_date,
                        status="success",
                        rows=len(df)
                    )
                    
                    all_data.append(df)
                    
            except Exception as e:
                self.audit.log(
                    action="get_price",
                    data_source=source,
                    security=sec,
                    start_date=start_date,
                    end_date=end_date,
                    status="error",
                    error=str(e)
                )
                logger.error(f"获取 {sec} 价格数据失败: {e}")
        
        if all_data:
            return pd.concat(all_data)
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str, 
                         source: str = None) -> Dict:
        """获取基本面数据"""
        source = source or self.primary_source
        
        if not source or source not in self.data_sources:
            raise ValueError("没有可用的数据源")
        
        ds = self.data_sources[source]
        
        if not ds.connected:
            raise ConnectionError(f"数据源 {source} 未连接")
        
        return ds.get_fundamentals(security, date)
    
    def get_cache_stats(self) -> Dict:
        """获取缓存统计"""
        return self.cache.get_stats()
    
    def get_audit_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        return self.audit.get_logs(date, limit)
    
    def clear_cache(self, older_than_days: int = None):
        """清理缓存"""
        self.cache.clear(older_than_days)
    
    def get_status(self) -> Dict:
        """获取数据中台状态"""
        return {
            "data_sources": {
                name: {
                    "connected": ds.connected,
                    "is_primary": name == self.primary_source
                }
                for name, ds in self.data_sources.items()
            },
            "cache": self.cache.get_stats(),
            "primary_source": self.primary_source
        }


# 全局数据中台实例
_data_center: Optional[DataCenter] = None


def get_data_center() -> DataCenter:
    """获取全局数据中台实例"""
    global _data_center
    if _data_center is None:
        _data_center = DataCenter()
    return _data_center


数据中台模块
基于《机构级量化研究与实盘交易平台构建方案》中的数据系统设计

支持功能：
1. 多源数据接入（JQData、TuShare、Wind等）
2. 本地缓存层（HDF5/Parquet文件格式）
3. 数据更新与审计
4. 统一数据接口
"""
import os
import json
import hashlib
import logging
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union
import pandas as pd

logger = logging.getLogger(__name__)


class DataSource:
    """数据源基类"""
    
    def __init__(self, name: str):
        self.name = name
        self.connected = False
    
    def connect(self) -> bool:
        """连接数据源"""
        raise NotImplementedError
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str, 
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        raise NotImplementedError
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        raise NotImplementedError


class JQDataSource(DataSource):
    """聚宽数据源"""
    
    def __init__(self):
        super().__init__("JQData")
        self.jq = None
    
    def connect(self, username: str = None, password: str = None) -> bool:
        """连接聚宽"""
        try:
            import jqdatasdk as jq
            self.jq = jq
            
            if username and password:
                jq.auth(username, password)
            
            # 验证连接
            count = jq.get_query_count()
            if count:
                self.connected = True
                logger.info(f"JQData连接成功，剩余查询次数: {count.get('spare', 'N/A')}")
                return True
            
        except Exception as e:
            logger.error(f"JQData连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        fields = fields or ['open', 'high', 'low', 'close', 'volume', 'money']
        
        try:
            df = self.jq.get_price(
                security,
                start_date=start_date,
                end_date=end_date,
                frequency=frequency,
                fields=fields
            )
            return df
        except Exception as e:
            logger.error(f"获取价格数据失败: {e}")
            raise
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.jq:
            raise ConnectionError("JQData未连接")
        
        try:
            from jqdatasdk import query, valuation, indicator
            
            q = query(
                valuation.code,
                valuation.pe_ratio,
                valuation.pb_ratio,
                valuation.ps_ratio,
                valuation.market_cap,
                indicator.roe,
                indicator.roa,
                indicator.gross_profit_margin,
            ).filter(
                valuation.code == security
            )
            
            df = self.jq.get_fundamentals(q, date)
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"获取基本面数据失败: {e}")
        
        return {}


class TuShareDataSource(DataSource):
    """TuShare数据源"""
    
    def __init__(self):
        super().__init__("TuShare")
        self.pro = None
    
    def connect(self, token: str = None, **kwargs) -> bool:
        """连接TuShare"""
        try:
            import tushare as ts
            
            if token:
                ts.set_token(token)
            
            self.pro = ts.pro_api()
            
            # 验证连接
            df = self.pro.trade_cal(exchange='SSE', start_date='20240101', end_date='20240101')
            if df is not None:
                self.connected = True
                logger.info("TuShare连接成功")
                return True
                
        except Exception as e:
            logger.error(f"TuShare连接失败: {e}")
        
        return False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            # TuShare股票代码格式转换
            ts_code = self._convert_code(security)
            
            df = self.pro.daily(
                ts_code=ts_code,
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            
            if df is not None and len(df) > 0:
                # 转换列名以匹配统一格式
                df = df.rename(columns={
                    'trade_date': 'date',
                    'vol': 'volume',
                    'amount': 'money'
                })
                df['date'] = pd.to_datetime(df['date'])
                df = df.set_index('date').sort_index()
                return df
            
        except Exception as e:
            logger.error(f"TuShare获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> TuShare格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.pro:
            raise ConnectionError("TuShare未连接")
        
        try:
            ts_code = self._convert_code(security)
            
            # 获取日常指标
            df = self.pro.daily_basic(
                ts_code=ts_code,
                trade_date=date.replace('-', ''),
                fields='ts_code,trade_date,pe,pb,ps,total_mv,circ_mv'
            )
            
            if df is not None and len(df) > 0:
                return df.iloc[0].to_dict()
            
        except Exception as e:
            logger.error(f"TuShare获取基本面数据失败: {e}")
        
        return {}


class WindDataSource(DataSource):
    """
    Wind数据源
    
    需要安装Wind金融终端和Python API
    """
    
    def __init__(self):
        super().__init__("Wind")
        self.w = None
    
    def connect(self, **kwargs) -> bool:
        """连接Wind"""
        try:
            from WindPy import w
            self.w = w
            
            # 启动Wind
            result = w.start()
            
            if result.ErrorCode == 0:
                self.connected = True
                logger.info("Wind连接成功")
                return True
            else:
                logger.error(f"Wind启动失败: {result.Data}")
                
        except ImportError:
            logger.warning("WindPy未安装，Wind数据源不可用")
        except Exception as e:
            logger.error(f"Wind连接失败: {e}")
        
        return False
    
    def disconnect(self):
        """断开Wind连接"""
        if self.w:
            try:
                self.w.stop()
            except:
                pass
        self.connected = False
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """获取价格数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            # Wind代码格式转换
            wind_code = self._convert_code(security)
            
            # 字段映射
            wind_fields = "open,high,low,close,volume,amt"
            
            result = self.w.wsd(
                wind_code, 
                wind_fields,
                start_date, 
                end_date,
                "Fill=Previous"
            )
            
            if result.ErrorCode == 0:
                df = pd.DataFrame(
                    result.Data,
                    index=['open', 'high', 'low', 'close', 'volume', 'money'],
                    columns=result.Times
                ).T
                df.index = pd.to_datetime(df.index)
                return df
            else:
                logger.error(f"Wind获取数据失败: {result.Data}")
                
        except Exception as e:
            logger.error(f"Wind获取价格数据失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """获取基本面数据"""
        if not self.connected or not self.w:
            raise ConnectionError("Wind未连接")
        
        try:
            wind_code = self._convert_code(security)
            
            result = self.w.wss(
                wind_code,
                "pe_ttm,pb_lf,ps_ttm,roe_ttm,roa_ttm,grossprofitmargin",
                f"tradeDate={date}"
            )
            
            if result.ErrorCode == 0:
                return {
                    'pe_ratio': result.Data[0][0],
                    'pb_ratio': result.Data[1][0],
                    'ps_ratio': result.Data[2][0],
                    'roe': result.Data[3][0],
                    'roa': result.Data[4][0],
                    'gross_profit_margin': result.Data[5][0],
                }
                
        except Exception as e:
            logger.error(f"Wind获取基本面数据失败: {e}")
        
        return {}
    
    def _convert_code(self, security: str) -> str:
        """转换股票代码格式"""
        # JQ格式: 000001.XSHE -> Wind格式: 000001.SZ
        if '.XSHE' in security:
            return security.replace('.XSHE', '.SZ')
        elif '.XSHG' in security:
            return security.replace('.XSHG', '.SH')
        return security


class LocalCSVDataSource(DataSource):
    """
    本地CSV数据源
    
    支持从本地CSV文件加载数据
    """
    
    def __init__(self, data_dir: str = None):
        super().__init__("LocalCSV")
        if data_dir:
            self.data_dir = Path(data_dir)
        else:
            self.data_dir = Path(__file__).parent.parent / "data" / "local"
        
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def connect(self, **kwargs) -> bool:
        """连接（本地数据源始终可用）"""
        self.connected = True
        logger.info(f"本地CSV数据源已就绪: {self.data_dir}")
        return True
    
    def get_price(self, security: str, start_date: str, end_date: str,
                  frequency: str = 'daily', fields: List[str] = None) -> pd.DataFrame:
        """从本地CSV获取价格数据"""
        if not self.connected:
            raise ConnectionError("本地数据源未连接")
        
        # 查找对应的CSV文件
        code = security.split('.')[0]
        csv_file = self.data_dir / f"{code}.csv"
        
        if not csv_file.exists():
            logger.warning(f"本地数据文件不存在: {csv_file}")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(csv_file, parse_dates=['date'], index_col='date')
            
            # 过滤日期范围
            start = pd.to_datetime(start_date)
            end = pd.to_datetime(end_date)
            df = df[(df.index >= start) & (df.index <= end)]
            
            # 过滤字段
            if fields:
                available_fields = [f for f in fields if f in df.columns]
                df = df[available_fields]
            
            return df
            
        except Exception as e:
            logger.error(f"读取本地CSV失败: {e}")
        
        return pd.DataFrame()
    
    def get_fundamentals(self, security: str, date: str) -> Dict:
        """本地数据源不支持基本面数据"""
        return {}
    
    def import_csv(self, csv_path: str, security: str) -> bool:
        """导入CSV数据"""
        try:
            code = security.split('.')[0]
            target_file = self.data_dir / f"{code}.csv"
            
            # 复制文件
            import shutil
            shutil.copy(csv_path, target_file)
            
            logger.info(f"导入CSV数据成功: {security}")
            return True
            
        except Exception as e:
            logger.error(f"导入CSV失败: {e}")
            return False


class DataCache:
    """本地数据缓存"""
    
    def __init__(self, cache_dir: str = None):
        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parent.parent / "data" / "cache"
        
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # 缓存元数据
        self.meta_file = self.cache_dir / "cache_meta.json"
        self.meta = self._load_meta()
    
    def _load_meta(self) -> Dict:
        """加载缓存元数据"""
        if self.meta_file.exists():
            try:
                with open(self.meta_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return {"entries": {}, "stats": {"hits": 0, "misses": 0}}
    
    def _save_meta(self):
        """保存缓存元数据"""
        with open(self.meta_file, 'w') as f:
            json.dump(self.meta, f, indent=2, default=str)
    
    def _get_cache_key(self, data_type: str, security: str, 
                       start_date: str, end_date: str, **kwargs) -> str:
        """生成缓存键"""
        key_str = f"{data_type}:{security}:{start_date}:{end_date}:{json.dumps(kwargs, sort_keys=True)}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def get(self, data_type: str, security: str, start_date: str, 
            end_date: str, **kwargs) -> Optional[pd.DataFrame]:
        """从缓存获取数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        if cache_key in self.meta["entries"]:
            entry = self.meta["entries"][cache_key]
            
            # 检查是否过期
            expire_time = datetime.fromisoformat(entry["expire_time"])
            if datetime.now() < expire_time and cache_file.exists():
                try:
                    df = pd.read_parquet(cache_file)
                    self.meta["stats"]["hits"] += 1
                    logger.debug(f"缓存命中: {cache_key}")
                    return df
                except Exception as e:
                    logger.warning(f"读取缓存失败: {e}")
        
        self.meta["stats"]["misses"] += 1
        return None
    
    def set(self, data_type: str, security: str, start_date: str, end_date: str,
            data: pd.DataFrame, ttl_hours: int = 24, **kwargs):
        """设置缓存数据"""
        cache_key = self._get_cache_key(data_type, security, start_date, end_date, **kwargs)
        cache_file = self.cache_dir / f"{cache_key}.parquet"
        
        try:
            data.to_parquet(cache_file)
            
            self.meta["entries"][cache_key] = {
                "data_type": data_type,
                "security": security,
                "start_date": start_date,
                "end_date": end_date,
                "created_time": datetime.now().isoformat(),
                "expire_time": (datetime.now() + timedelta(hours=ttl_hours)).isoformat(),
                "size_bytes": cache_file.stat().st_size,
                "rows": len(data)
            }
            
            self._save_meta()
            logger.debug(f"数据已缓存: {cache_key}")
            
        except Exception as e:
            logger.error(f"缓存数据失败: {e}")
    
    def clear(self, older_than_days: int = None):
        """清理缓存"""
        if older_than_days is None:
            # 清理所有
            for f in self.cache_dir.glob("*.parquet"):
                f.unlink()
            self.meta = {"entries": {}, "stats": {"hits": 0, "misses": 0}}
        else:
            # 清理过期缓存
            cutoff = datetime.now() - timedelta(days=older_than_days)
            keys_to_remove = []
            
            for key, entry in self.meta["entries"].items():
                expire_time = datetime.fromisoformat(entry["expire_time"])
                if expire_time < cutoff:
                    keys_to_remove.append(key)
                    cache_file = self.cache_dir / f"{key}.parquet"
                    if cache_file.exists():
                        cache_file.unlink()
            
            for key in keys_to_remove:
                del self.meta["entries"][key]
        
        self._save_meta()
        logger.info(f"缓存已清理")
    
    def get_stats(self) -> Dict:
        """获取缓存统计"""
        total_size = sum(
            entry.get("size_bytes", 0) 
            for entry in self.meta["entries"].values()
        )
        
        return {
            "total_entries": len(self.meta["entries"]),
            "total_size_mb": total_size / (1024 * 1024),
            "hits": self.meta["stats"]["hits"],
            "misses": self.meta["stats"]["misses"],
            "hit_rate": (
                self.meta["stats"]["hits"] / 
                (self.meta["stats"]["hits"] + self.meta["stats"]["misses"])
                if (self.meta["stats"]["hits"] + self.meta["stats"]["misses"]) > 0
                else 0
            )
        }


class DataAuditLog:
    """数据审计日志"""
    
    def __init__(self, log_dir: str = None):
        if log_dir:
            self.log_dir = Path(log_dir)
        else:
            self.log_dir = Path(__file__).parent.parent / "data" / "audit"
        
        self.log_dir.mkdir(parents=True, exist_ok=True)
    
    def log(self, action: str, data_source: str, security: str, 
            start_date: str, end_date: str, status: str, 
            rows: int = 0, error: str = None):
        """记录审计日志"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "data_source": data_source,
            "security": security,
            "start_date": start_date,
            "end_date": end_date,
            "status": status,
            "rows": rows,
            "error": error
        }
        
        # 按日期分文件
        log_file = self.log_dir / f"audit_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def get_logs(self, date: str = None, limit: int = 100) -> List[Dict]:
        """获取审计日志"""
        logs = []
        
        if date:
            log_files = [self.log_dir / f"audit_{date.replace('-', '')}.jsonl"]
        else:
            log_files = sorted(self.log_dir.glob("audit_*.jsonl"), reverse=True)
        
        for log_file in log_files:
            if log_file.exists():
                with open(log_file, 'r') as f:
                    for line in f:
                        logs.append(json.loads(line))
                        if len(logs) >= limit:
                            return logs
        
        return logs


class DataCenter:
    """数据中台 - 统一数据接口"""
    
    def __init__(self, cache_dir: str = None):
        self.data_sources: Dict[str, DataSource] = {}
        self.primary_source: Optional[str] = None
        self.cache = DataCache(cache_dir)
        self.audit = DataAuditLog()
        
        # 初始化数据源
        self._init_data_sources()
    
    def _init_data_sources(self):
        """初始化数据源"""
        # 添加JQData
        self.data_sources["jqdata"] = JQDataSource()
        
        # 添加TuShare
        self.data_sources["tushare"] = TuShareDataSource()
        
        # 添加Wind
        self.data_sources["wind"] = WindDataSource()
        
        # 添加本地CSV
        self.data_sources["local"] = LocalCSVDataSource()
    
    def add_data_source(self, name: str, source: DataSource):
        """添加自定义数据源"""
        self.data_sources[name] = source
   